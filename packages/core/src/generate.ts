import { DatabaseSchema, KnexBridgeConfig, GenerationResult } from './types';
import { 
  generateTypeInterface, 
  generateZodSchema, 
  generateInsertUpdateTypes,
  generateRelationTypes 
} from './generator';
import { GenerationError } from './errors';
import { DEFAULT_CONFIG } from './constants';
import { writeFileSync, mkdirSync, existsSync } from 'fs';
import { join } from 'path';

/**
 * Main generation function
 */
export function generate(
  schema: DatabaseSchema,
  outDir: string,
  config: Partial<KnexBridgeConfig> = {}
): GenerationResult {
  const startTime = Date.now();
  const mergedConfig = { ...DEFAULT_CONFIG, ...config } as KnexBridgeConfig;
  const warnings: string[] = [];
  const filesGenerated: string[] = [];

  try {
    // Ensure output directory exists
    if (!existsSync(outDir)) {
      mkdirSync(outDir, { recursive: true });
    }

    let typeGenStart = 0;
    let zodGenStart = 0;

    // Generate types file
    if (mergedConfig.generateTypes) {
      typeGenStart = Date.now();
      const typesFile = generateTypesFile(schema, mergedConfig, warnings);
      const typesPath = join(outDir, 'bridge.schema.ts');
      writeFileSync(typesPath, typesFile);
      filesGenerated.push(typesPath);
    }

    // Generate Zod schemas file
    if (mergedConfig.generateZod) {
      zodGenStart = Date.now();
      const zodFile = generateZodFile(schema, mergedConfig, warnings);
      const zodPath = join(outDir, 'bridge.validation.ts');
      writeFileSync(zodPath, zodFile);
      filesGenerated.push(zodPath);
    }

    // Generate index file
    const indexFile = generateIndexFile(mergedConfig);
    const indexPath = join(outDir, 'index.ts');
    writeFileSync(indexPath, indexFile);
    filesGenerated.push(indexPath);

    const totalTime = Date.now() - startTime;

    return {
      filesGenerated,
      tablesProcessed: schema.tables.length,
      warnings,
      metrics: {
        totalTime,
        filesWritten: filesGenerated.length,
        typeGenerationTime: typeGenStart ? Date.now() - typeGenStart : undefined,
        zodGenerationTime: zodGenStart ? Date.now() - zodGenStart : undefined,
      },
    };
  } catch (error) {
    throw new GenerationError(
      `Failed to generate files: ${(error as Error).message}`,
      { outDir },
      error as Error
    );
  }
}

/**
 * Generate types.ts file
 */
function generateTypesFile(
  schema: DatabaseSchema,
  config: KnexBridgeConfig,
  warnings: string[]
): string {
  let content = '// Auto-generated by KnexBridge\n';
  content += '// Do not edit manually\n\n';

  for (const table of schema.tables) {
    // Main interface
    const { code: interfaceCode, warnings: interfaceWarnings } = generateTypeInterface(table, config);
    content += interfaceCode + '\n';
    warnings.push(...interfaceWarnings);

    // Insert/Update types
    if (config.generateInsertTypes || config.generateUpdateTypes) {
      content += generateInsertUpdateTypes(table, config) + '\n';
    }

    // Relation types
    if (config.generateRelations) {
      content += generateRelationTypes(table, schema.tables, config) + '\n';
    }
  }

  return content;
}

/**
 * Generate schemas.ts file
 */
function generateZodFile(
  schema: DatabaseSchema,
  config: KnexBridgeConfig,
  warnings: string[]
): string {
  let content = '// Auto-generated by KnexBridge\n';
  content += '// Do not edit manually\n\n';
  content += "import { z } from 'zod';\n\n";

  for (const table of schema.tables) {
    const { code, warnings: schemaWarnings } = generateZodSchema(table, config);
    content += code + '\n';
    warnings.push(...schemaWarnings);
  }

  return content;
}

/**
 * Generate index.ts file
 */
function generateIndexFile(config: KnexBridgeConfig): string {
  let content = '// Auto-generated by KnexBridge\n';
  content += '// Do not edit manually\n\n';

  if (config.generateTypes) {
    content += "export * from './bridge.schema';\n";
  }

  if (config.generateZod) {
    content += "export * from './bridge.validation';\n";
  }

  return content;
}
